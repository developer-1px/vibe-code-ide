# Vue Logic Visualizer - 서비스 분석 보고서

**작성일**: 2025년 12월 26일
**프로젝트명**: Vue Logic Visualizer
**버전**: 0.0.0

---

## 📋 목차

1. [개요](#1-개요)
2. [핵심 기능](#2-핵심-기능)
3. [기술 스택](#3-기술-스택)
4. [아키텍처 분석](#4-아키텍처-분석)
5. [주요 모듈 상세 분석](#5-주요-모듈-상세-분석)
6. [데이터 흐름](#6-데이터-흐름)
7. [사용자 인터랙션](#7-사용자-인터랙션)
8. [기술적 특징](#8-기술적-특징)
9. [활용 사례](#9-활용-사례)
10. [개선 제안](#10-개선-제안)

---

## 1. 개요

### 1.1 서비스 정의

**Vue Logic Visualizer**는 Vue.js 프로젝트의 컴포넌트 구조와 변수 의존성 관계를 실시간으로 시각화하는 개발자 도구입니다. 복잡한 Vue 컴포넌트의 로직 흐름을 그래프 형태로 표현하여 코드 이해도를 높이고, AI 기반 설명 기능을 통해 학습과 디버깅을 지원합니다.

### 1.2 핵심 가치 제안

- **가시성 향상**: 복잡한 Vue 컴포넌트의 데이터 흐름을 한눈에 파악
- **학습 도구**: 새로운 코드베이스를 빠르게 이해하는 온보딩 도구
- **디버깅 지원**: 변수 간 의존성 추적을 통한 버그 원인 파악
- **리팩토링 가이드**: 코드 구조 개선 시 영향 범위 분석

### 1.3 타겟 사용자

- Vue.js 개발자 (초급~중급)
- 레거시 Vue 프로젝트 유지보수 담당자
- 코드 리뷰어 및 기술 리더
- Vue.js 학습자

---

## 2. 핵심 기능

### 2.1 실시간 코드 파싱 및 분석

**기능 설명**:
사용자가 좌측 사이드바에서 Vue 파일을 편집하면, 실시간으로 다음 작업이 수행됩니다:

1. **Vue SFC 파싱**: `@vue/compiler-sfc`를 사용하여 `<script>`, `<template>` 섹션 추출
2. **AST 생성**: `@babel/parser`로 JavaScript/TypeScript 코드를 추상 구문 트리로 변환
3. **의존성 추출**: AST를 순회하며 변수, 함수, 컴포저블 간의 관계 파악
4. **그래프 구축**: 노드와 엣지로 구성된 의존성 그래프 생성

**지원하는 코드 패턴**:
- Vue Composition API (`ref`, `computed`, `reactive`)
- Composable 함수 (`useFetchData`, `useMarketplaceFilter`)
- Import/Export 관계 추적
- 템플릿 내 컴포넌트 사용 분석

### 2.2 D3.js 기반 인터랙티브 시각화

**시각화 방식**:
- **Force-Directed Graph**: 노드 간 관계를 물리 시뮬레이션으로 배치
- **계층적 레이아웃**: 좌에서 우로 흐르는 데이터 파이프라인 형태
- **파일별 그룹핑**: 같은 파일의 변수들을 시각적으로 묶어 표시

**인터랙션**:
- **Pan & Zoom**: 마우스 드래그와 스크롤로 캔버스 탐색
- **노드 확장/축소**: 변수 노드 클릭 시 종속성 재귀적 펼치기
- **연결선 하이라이트**: 의존성 관계를 화살표로 명확히 표시

### 2.3 점진적 탐색 (Progressive Exploration)

**작동 원리**:

초기 상태에서는 최상위 노드(템플릿 루트, 함수 호출)만 표시하고, 사용자가 관심 있는 변수를 클릭하면 해당 변수의 모든 종속성이 재귀적으로 펼쳐집니다.

```typescript
// 노드 클릭 시 재귀적으로 의존성 확장
const expandRecursive = (id: string) => {
    next.add(id);
    const node = fullNodeMap.get(id);
    if (node) {
        node.dependencies.forEach(depId => {
            if (fullNodeMap.has(depId)) {
                expandRecursive(depId);
            }
        });
    }
};
```

**장점**:
- 초기 화면 복잡도 감소
- 사용자가 필요한 부분만 집중 탐색 가능
- 대규모 프로젝트에서도 성능 유지

### 2.4 AI 기반 로직 설명 (Gemini Integration)

**기능**:
Gemini AI를 활용하여 선택한 변수의 로직 흐름을 자연어로 설명합니다.

```typescript
// 변수명, 코드 컨텍스트, 의존성 체인을 AI에 전달
const prompt = `
    You are an expert Vue.js developer.
    I have a specific variable "${variableName}" in a Vue component.

    Here is the dependency chain: ${dependencyChain.join(' -> ')}.

    Explain briefly how "${variableName}" is calculated...
`;
```

**활용 예시**:
- 변수 `typeList`의 계산 로직 설명
- `useFetchMarketplaceCategory` composable의 데이터 흐름 해석

### 2.5 멀티파일 프로젝트 지원

**가상 파일 시스템**:
메모리 내에서 여러 `.vue`, `.ts` 파일을 관리하며, 파일 간 import 관계를 추적합니다.

```typescript
// 파일 경로와 코드 내용을 매핑
const DEFAULT_FILES: Record<string, string> = {
  'src/pages/MarketplaceIndex.vue': `...`,
  'src/model.ts': `...`,
  'src/entities/MarketplaceCategory/api/useFetchMarketplaceCategory.ts': `...`,
};
```

**경로 해석 지원**:
- 상대 경로: `./component.vue`, `../utils.ts`
- 경로 별칭: `@/components/Button.vue`
- Nuxt 스타일: `~~/layers/marketplace/...`

---

## 3. 기술 스택

### 3.1 프론트엔드 프레임워크

| 기술 | 버전 | 용도 |
|------|------|------|
| **React** | 19.2.3 | UI 프레임워크 (최신 Concurrent 모드) |
| **TypeScript** | 5.8.2 | 타입 안전성 |
| **Vite** | 6.2.0 | 빌드 도구 및 개발 서버 (HMR) |

### 3.2 코드 파싱 및 분석

| 라이브러리 | 역할 |
|-----------|------|
| **@vue/compiler-sfc** (3.4.19) | Vue Single File Component 파싱 |
| **@babel/parser** (7.23.9) | JavaScript/TypeScript AST 생성 |

### 3.3 시각화 및 UI

| 기술 | 용도 |
|------|------|
| **D3.js** (7.9.0) | Force-directed graph 레이아웃 및 줌/팬 |
| **Tailwind CSS** (CDN) | 스타일링 (다크 테마) |
| **Lucide React** (0.562.0) | 아이콘 라이브러리 |

### 3.4 AI 통합

| 서비스 | API |
|--------|-----|
| **Google Gemini** | `@google/genai` (1.34.0) - 코드 설명 생성 |

### 3.5 개발 환경

- **포트**: 3000 (개발 서버)
- **Node.js**: >= 18.0.0 권장
- **패키지 매니저**: npm

---

## 4. 아키텍처 분석

### 4.1 전체 시스템 구조

```
┌─────────────────────────────────────────────────────────┐
│                     React App (App.tsx)                  │
│                                                           │
│  ┌─────────────┐              ┌─────────────────────┐  │
│  │  Sidebar    │              │  PipelineCanvas     │  │
│  │ (코드 편집기)  │              │  (D3.js 시각화)      │  │
│  └─────────────┘              └─────────────────────┘  │
│         │                                │              │
│         ▼                                ▼              │
│  ┌──────────────────────────────────────────────────┐  │
│  │         Files State (Virtual File System)         │  │
│  │         Record<string, string>                    │  │
│  └──────────────────────────────────────────────────┘  │
│                        │                                │
│                        ▼                                │
│  ┌──────────────────────────────────────────────────┐  │
│  │          parseVueCode() (useMemo trigger)         │  │
│  └──────────────────────────────────────────────────┘  │
│                        │                                │
│                        ▼                                │
│  ┌──────────────────────────────────────────────────┐  │
│  │              ProjectParser Class                  │  │
│  │   ┌──────────────────────────────────────────┐  │  │
│  │   │ 1. @vue/compiler-sfc (SFC 파싱)          │  │  │
│  │   │ 2. @babel/parser (AST 생성)              │  │  │
│  │   │ 3. AST 순회 (변수/함수/import 추출)      │  │  │
│  │   │ 4. 의존성 그래프 구축                     │  │  │
│  │   └──────────────────────────────────────────┘  │  │
│  └──────────────────────────────────────────────────┘  │
│                        │                                │
│                        ▼                                │
│  ┌──────────────────────────────────────────────────┐  │
│  │           GraphData (노드 배열)                   │  │
│  │   { nodes: VariableNode[] }                      │  │
│  └──────────────────────────────────────────────────┘  │
│                        │                                │
│                        ▼                                │
│  ┌──────────────────────────────────────────────────┐  │
│  │       useCanvasLayout (D3 Force 시뮬레이션)       │  │
│  │   - 노드 위치 계산 (x, y 좌표)                   │  │
│  │   - 계층적 트리 레이아웃                          │  │
│  │   - 파일별 컴포넌트 그룹핑                        │  │
│  └──────────────────────────────────────────────────┘  │
│                        │                                │
│                        ▼                                │
│  ┌──────────────────────────────────────────────────┐  │
│  │         렌더링 (Canvas + CodeCard 노드)           │  │
│  └──────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────┘
```

### 4.2 레이어 구조

#### **1. Presentation Layer (UI)**
- `App.tsx`: 메인 컨테이너, 상태 관리
- `Sidebar.tsx`: 코드 에디터 인터페이스
- `PipelineCanvas.tsx`: 그래프 시각화 컨테이너
- `CodeCard.tsx`: 개별 변수 노드 카드

#### **2. Business Logic Layer**
- `services/codeParser.ts`: 파싱 API 엔트리포인트
- `services/parser/ProjectParser.ts`: 핵심 파싱 로직
- `services/parser/astUtils.ts`: AST 유틸리티
- `services/parser/pathUtils.ts`: 경로 해석

#### **3. Data Layer**
- `entities/VariableNode/model/types.ts`: 데이터 모델 정의
- `constants.ts`: 기본 Vue 프로젝트 파일

#### **4. Integration Layer**
- `services/geminiService.ts`: Gemini AI 통합

---

## 5. 주요 모듈 상세 분석

### 5.1 ProjectParser (핵심 파싱 엔진)

**파일 위치**: `services/parser/ProjectParser.ts`

**주요 책임**:
1. 재귀적으로 파일 처리 (`processFile` 메서드)
2. Import/Export 레지스트리 관리
3. 변수 노드 생성 및 의존성 연결

**처리 흐름**:

```typescript
class ProjectParser {
  private files: Record<string, string>;
  private nodes: Map<string, VariableNode> = new Map();
  private processedFiles: Set<string> = new Set();
  private exportsRegistry: Map<string, Map<string, string>> = new Map();

  processFile(filePath: string) {
    // 1. Vue SFC 파싱 (script, template 추출)
    const { descriptor } = parseSFC(content);

    // 2. Babel로 AST 생성
    const ast = parseBabel(scriptContent, {
      sourceType: 'module',
      plugins: ['typescript']
    });

    // 3. Import 스캔 및 재귀 처리
    ast.program.body.forEach(node => {
      if (node.type === 'ImportDeclaration') {
        const targetFile = resolveImportPath(node.source.value);
        this.processFile(targetFile); // 재귀 호출
      }
    });

    // 4. 변수 선언 추출 (const, let, var, function)
    // 5. 의존성 추출 (식별자 참조 분석)
    // 6. Template 내 컴포넌트 사용 분석
  }
}
```

**노드 타입 분류**:

| 타입 | 설명 | 예시 |
|------|------|------|
| `ref` | Vue ref 변수 | `const isShowDetail = ref(false)` |
| `computed` | Vue computed 속성 | `const typeList = computed(...)` |
| `function` | 일반 함수 | `function handleSetType(code) {...}` |
| `module` | Import된 모듈 | `import useFetchCategory from '...'` |
| `call` | 함수 호출 | `useFetchMarketplaceCategory()` |
| `template` | 템플릿 루트 | `<template>` 섹션 전체 |

### 5.2 useCanvasLayout (레이아웃 엔진)

**파일 위치**: `components/PipelineCanvas/useCanvasLayout.ts`

**핵심 알고리즘**:

```typescript
// 1. 가상 루트 노드 생성
const rootDeps = [templateRootId, ...callNodes];

// 2. 시각적 트리 구축 (재귀 탐색)
const buildVisualTree = (nodeId, level, path, parentId) => {
  // 순환 참조 방지
  if (visited.has(nodeId)) return null;

  // 의존성을 사용 순서대로 정렬
  const sortedDeps = [...node.dependencies].sort((a, b) => {
    return getUsageIndex(node.codeSnippet, a) - getUsageIndex(node.codeSnippet, b);
  });

  // 자식 노드 재귀 생성
  sortedDeps.forEach(depId => {
    const child = buildVisualTree(depId, level + 1, [...path, nodeId], nodeId);
    if (child) node.children.push(child);
  });
};

// 3. 서브트리 높이 계산
const computeHeights = (node) => {
  const myHeight = estimateNodeHeight(node);
  const childrenHeight = sum(node.children.map(c => c.subtreeHeight));
  node.subtreeHeight = Math.max(myHeight, childrenHeight + gaps);
};

// 4. 좌표 할당 (좌에서 우로)
node.x = -(level * LEVEL_SPACING); // 음수 X 좌표 (RTL 역순)
node.y = startY + (node.subtreeHeight / 2) - (myHeight / 2);
```

**레이아웃 특징**:
- **Right-to-Left**: 템플릿(오른쪽) → 의존성(왼쪽) 방향
- **계층적**: `level` 값에 따라 X 좌표 결정
- **수직 정렬**: 형제 노드 간 `VERTICAL_GAP` 간격 유지

### 5.3 PipelineCanvas (시각화 컨테이너)

**상태 관리**:

```typescript
// 점진적 탐색을 위한 가시성 상태
const [visibleNodeIds, setVisibleNodeIds] = useState<Set<string>>(new Set());

// 초기 상태: 템플릿 루트 + 최상위 함수 호출만 표시
useEffect(() => {
  const initialSet = new Set<string>();
  if (templateRootId) initialSet.add(templateRootId);
  initialData.nodes.forEach(n => {
    if (n.type === 'call' && n.filePath === entryFile) {
      initialSet.add(n.id);
    }
  });
  setVisibleNodeIds(initialSet);
}, [initialData]);
```

**노드 클릭 핸들러**:

```typescript
const handleTokenClick = (token: string, sourceNodeId: string) => {
  if (isCurrentlyVisible) {
    // FOLD: 노드 숨기기
    next.delete(token);
  } else {
    // UNFOLD: 재귀적으로 모든 의존성 펼치기
    const expandRecursive = (id: string) => {
      if (next.has(id)) return;
      next.add(id);
      fullNodeMap.get(id)?.dependencies.forEach(depId => {
        expandRecursive(depId);
      });
    };
    expandRecursive(token);

    // 카메라 자동 포커스
    setLastExpandedId(token);
  }
};
```

### 5.4 useD3Zoom (줌/팬 컨트롤)

**기능**:
- **마우스 드래그**: 캔버스 이동
- **마우스 휠**: 확대/축소
- **프로그래매틱 줌**: 특정 노드로 자동 이동

```typescript
const centerOnNode = (targetNode: CanvasNode) => {
  const containerWidth = containerRect.width;
  const containerHeight = containerRect.height;

  const targetCenterX = targetNode.x + nodeWidth / 2;
  const targetCenterY = targetNode.y + nodeHeight / 2;

  // 타겟을 화면 중앙으로 이동
  const newX = containerWidth / 2 - targetCenterX * currentScale;
  const newY = containerHeight / 2 - targetCenterY * currentScale;

  setTransform({ x: newX, y: newY, k: currentScale });
};
```

---

## 6. 데이터 흐름

### 6.1 파싱 파이프라인

```
사용자 코드 편집
    ↓
setFiles({ ...prev, [fileName]: newContent })
    ↓
App.tsx의 useMemo 트리거
    ↓
parseVueCode(files, entryFile)
    ↓
ProjectParser.parseProject(entryFile)
    ↓
processFile 재귀 호출
    ├─ parseSFC (Vue 파일)
    ├─ parseBabel (AST)
    ├─ Import 추적 및 재귀
    ├─ 변수 노드 생성
    └─ 의존성 연결
    ↓
GraphData { nodes: VariableNode[] }
    ↓
useCanvasLayout (레이아웃 계산)
    ↓
CanvasNode[] (x, y 좌표 포함)
    ↓
PipelineCanvas 렌더링
```

### 6.2 인터랙션 흐름

```
노드 클릭 (CodeCard)
    ↓
handleTokenClick(tokenId)
    ↓
visibleNodeIds 업데이트 (재귀적 확장)
    ↓
useCanvasLayout 재계산
    ↓
layoutNodes 업데이트
    ↓
D3 Force 시뮬레이션 재실행
    ↓
애니메이션과 함께 새 노드 표시
    ↓
centerOnNode (카메라 자동 이동)
```

---

## 7. 사용자 인터랙션

### 7.1 키보드 단축키

| 단축키 | 기능 |
|--------|------|
| `Cmd/Ctrl + \` | 사이드바 토글 |

### 7.2 마우스 인터랙션

| 동작 | 효과 |
|------|------|
| **드래그** | 캔버스 이동 (Pan) |
| **스크롤** | 확대/축소 (Zoom) |
| **노드 클릭** | 의존성 펼치기/접기 |
| **변수 토큰 클릭** | 해당 변수의 정의로 이동 |

### 7.3 UI 상태 피드백

- **파싱 성공**: 녹색 "Project Analysis Active" 배지
- **파싱 오류**: 빨간색 "Syntax Error" 배지 + 마지막 유효 그래프 표시
- **노드 확장**: 부드러운 애니메이션 (`transition-all duration-500`)
- **연결선**: 화살표 방향으로 데이터 흐름 표시

---

## 8. 기술적 특징

### 8.1 성능 최적화

#### **1. 점진적 렌더링**
- 초기에는 최상위 노드만 렌더링
- 사용자 요청 시에만 하위 의존성 로드
- 대규모 프로젝트에서도 초기 로딩 속도 보장

#### **2. useMemo 활용**
```typescript
const graphData = useMemo(() => {
  try {
    return parseVueCode(files, DEFAULT_ENTRY_FILE);
  } catch (e) {
    return null; // 에러 발생 시 null 반환
  }
}, [files]);
```
- 파일이 변경될 때만 파싱 재실행
- 불필요한 재계산 방지

#### **3. 에러 복원력**
```typescript
const [lastValidData, setLastValidData] = useState(graphData);
if (graphData && graphData !== lastValidData) {
  setLastValidData(graphData);
}
```
- 파싱 실패 시 마지막으로 유효했던 그래프 유지
- 사용자가 코드 수정 중에도 시각화 유지

### 8.2 확장 가능한 설계

#### **노드 타입 확장**
```typescript
type NodeType =
  | 'ref'
  | 'computed'
  | 'prop'
  | 'store'
  | 'function'
  | 'hook'
  | 'template'
  | 'call'
  | 'module';
```
- 새로운 Vue 패턴(e.g., Pinia store) 추가 용이

#### **파서 플러그인**
- Babel 플러그인 확장 가능 (`plugins: ['typescript', 'decorators']`)

### 8.3 개발자 경험

#### **타입 안전성**
- 전체 코드베이스 TypeScript 적용
- 인터페이스를 통한 계약 보장

```typescript
export interface VariableNode {
  id: string;
  label: string;
  filePath: string;
  type: NodeType;
  codeSnippet: string;
  startLine: number;
  dependencies: string[];
}
```

#### **핫 모듈 교체 (HMR)**
- Vite를 통한 빠른 개발 피드백
- 코드 변경 시 즉시 브라우저 업데이트

---

## 9. 활용 사례

### 9.1 코드 학습 및 온보딩

**시나리오**: 새로운 팀원이 복잡한 Vue 프로젝트를 이해해야 할 때

1. 진입점 컴포넌트(`MarketplaceIndex.vue`)의 템플릿 로드
2. 사용되는 각 컴포넌트를 클릭하여 내부 로직 탐색
3. `useFetchMarketplaceCategory` 같은 composable의 데이터 흐름 추적
4. AI 설명 기능으로 각 변수의 목적 이해

### 9.2 리팩토링 영향 분석

**시나리오**: `categoryCode` 변수의 타입을 변경하려는 경우

1. `categoryCode` 노드 클릭
2. 의존성 그래프에서 이 변수를 사용하는 모든 곳 확인
3. `typeList`, `isDim` 등 영향받는 computed 속성 파악
4. 안전하게 변경 범위 산정

### 9.3 버그 디버깅

**시나리오**: `typeList`가 빈 배열을 반환하는 버그

1. `typeList` computed 노드로 이동
2. 의존성 체인 추적: `typeList → categoryCode → useMarketplaceFilter`
3. `categoryCode`가 'all'일 때의 로직 흐름 확인
4. `categoryList`의 데이터 소스 `useFetchMarketplaceCategory` 검증

### 9.4 문서화 자동화

**시나리오**: 프로젝트 아키텍처 문서 작성

1. 시각화된 그래프를 스크린샷으로 캡처
2. 주요 데이터 흐름을 다이어그램으로 문서화
3. AI 설명을 기술 문서에 포함

---

## 10. 개선 제안

### 10.1 기능 확장

#### **1. 다중 프레임워크 지원**
- React Hooks 분석 지원
- Svelte, Angular 등 확장

#### **2. 실시간 협업**
- WebSocket 기반 멀티플레이어 편집
- 팀원 간 그래프 공유

#### **3. 코드 메트릭스 통합**
- 순환 복잡도 (Cyclic Complexity) 표시
- 사용되지 않는 변수 하이라이트

#### **4. 버전 비교**
- Git 커밋 간 의존성 변화 시각화
- 리팩토링 전후 비교

### 10.2 성능 개선

#### **1. 웹 워커**
- 파싱 작업을 백그라운드 스레드로 이동
- UI 블로킹 최소화

#### **2. 증분 파싱**
- 전체 재파싱 대신 변경된 파일만 업데이트
- Diff 알고리즘 적용

#### **3. 가상 스크롤**
- 수천 개 노드 렌더링 시 뷰포트 내부만 그리기

### 10.3 UX 개선

#### **1. 검색 기능**
- 변수명, 파일명으로 노드 빠르게 찾기
- 정규식 검색 지원

#### **2. 필터링**
- 노드 타입별 필터 (ref만 표시, computed만 표시)
- 파일별 필터

#### **3. 레이아웃 옵션**
- 수평 레이아웃 / 수직 레이아웃 토글
- 트리맵, 서클 팩 등 대안 시각화

#### **4. 테마 커스터마이징**
- 라이트 모드 / 다크 모드
- 색상 팔레트 변경

### 10.4 통합

#### **1. VS Code 확장**
- 에디터 내에서 직접 시각화 실행
- 파일 저장 시 자동 업데이트

#### **2. CI/CD 통합**
- Pull Request에 의존성 그래프 첨부
- 복잡도 증가 경고

#### **3. 스타일 가이드 검증**
- 너무 깊은 의존성 체인 경고
- Composable 네이밍 규칙 체크

---

## 11. 결론

### 11.1 핵심 성과

**Vue Logic Visualizer**는 다음 문제를 효과적으로 해결합니다:

1. **복잡도 가시화**: 복잡한 Vue 컴포넌트의 내부 구조를 직관적으로 이해
2. **학습 곡선 완화**: 새로운 코드베이스를 빠르게 파악
3. **디버깅 효율화**: 변수 간 관계 추적으로 버그 원인 신속 파악
4. **리팩토링 지원**: 변경 영향 범위를 시각적으로 검증

### 11.2 기술적 강점

- **실시간 분석**: useMemo 기반 효율적 재파싱
- **확장 가능한 아키텍처**: 새로운 노드 타입과 파서 플러그인 추가 용이
- **우수한 UX**: D3.js 기반 부드러운 인터랙션
- **AI 통합**: Gemini를 통한 자연어 설명

### 11.3 향후 발전 방향

이 도구는 다음과 같은 방향으로 발전할 수 있습니다:

1. **범용 코드 분석 도구**로 확장 (React, Angular 지원)
2. **팀 협업 플랫폼**으로 진화 (실시간 공유, 주석 기능)
3. **IDE 통합**을 통한 개발 워크플로우 개선
4. **교육 플랫폼**으로서의 활용 (Vue 학습 도구)

**Vue Logic Visualizer**는 단순한 시각화 도구를 넘어, 개발자의 생산성을 높이고 코드 품질을 향상시키는 **차세대 개발자 경험 도구**로 자리매김할 잠재력을 가지고 있습니다.

---

**보고서 작성**: AI Assistant (Claude Code)
**분석 대상**: Vue Logic Visualizer v0.0.0
**분석 날짜**: 2025-12-26